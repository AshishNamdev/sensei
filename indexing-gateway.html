---
layout: default
title: SenseiDB - Indexing &amp; Gateway
---
<div class="hero-unit">
  <h2>Indexing &amp; Gateway</h2>
  <p>This section describes how data are inserted into Sensei.</p>
</div>

<h2>Data Events</h2>
<p>
  Data events are units of indexing activities. Each data event is a tuple of (type,data,version). (versions are interpreted by Gateway semantics)
</p>
<p>
  Types of data events:
  <ul>
    <li>add (default) - inserts data into Sensei</li>
    <li>delete - deletes data from Sensei</li>
    <li>update - update partially on an existing event</li>
  </ul>
</p>

<h2>Examples of data events</h2>
<p>
<h4>Add event:</h4>
<pre class="prettyprint" id="javascript">
{"type":"add","data":{"id":1,"contents":"sensei is cool","attrib":"opensource"}}
</pre>
<p>since add is the default event type, this is equivalent to:</p>
<pre class="prettyprint" id="javascript">
{"id":1,"contents":"sensei is cool","attrib":"opensource"}
</pre>
<p>for add events with the same id, newer events overwrite existing events</p>
</p>

<p>
<h4>Update event:</h4>
<pre class="prettyprint" id="javascript">
{"type":"update","data":{"id":1,"attrib":"data system"}}
</pre>
<p>update events assume there is an existing event with the same id in the system. If no such event exists, this event will result in an error.</p>
</p>


<p>
<h4>Delete event:</h4>
<pre class="prettyprint" id="javascript">
{"type":"delete","id":1}
</pre>
<p>If no such event exists, this event is a no-op.</p>
</p>

<h2>Data Stream</h2>
<p>
  Stream of data events that Sensei consumes from via Gateways.
</p>
<p>
  Some properties of Data Streams:
<ul>
	<li>Versioned - each event on the stream has a monotonically increasing value indicating a unique point in the stream</li>
	<li>Ordered - ordering of all events should reflect the semantics of the application</li>
</ul> 	
</p>

<p>
  Some examples of data streams:
  <ul>
    <li>Twitter stream</li>
    <li>Activity tracking data, e.g. LinkedIn profile creation and update events</li>
    <li>Server logs</li>
  </ul>
</p>

<h2>Gateway</h2>
<p>
  Gateways are integration components between Sensei and Data Streams. Gateways serve the following purposes:
  <ul>
    <li>Read data events from data streams and proxy between Sensei and the data stream</li>
    <li>Interpret version semantics of data events read from the data stream</li>
  </ul>
</p>
<p>The following diagram illustrates how gateways fit into Sensei:</p>
<img src="images/sensei-gateway.png"/>
<p>
  Sensei comes with the following pre-written gateways:
  <ul>
    <li>
       <p>File - each line is a data event, and line number is the version.</p>
       <p>Configuration:</p>
       <pre class="prettyprint">
         sensei.gateway.type=file
         sensei.gateway.file.path = &lt;file-name&gt;
       </pre> 
    </li>
    <li>
       <p>JMS - each message is a data event, <code>System.nanoTime()</code> is used as version.</p>
       <p>Configuration:</p>
         <pre class="prettyprint">
         sensei.gateway.type=file
         sensei.gateway.jms.topic = &lt;topic name&gt;
         sensei.gateway.jms.clientId = &lt;client id&gt;
         sensei.gateway.jms.topicFactory = &lt;topic factory class name&gt;
         sensei.gateway.jms.connectionFactory = &lt;connection factory class name&gt;
         </pre>
    </li>
    <li>
       <p>JDBC - each element in the ResultSet is a data event, developer implements version semantics.</p>
       <p>Configuration:</p>
       <pre class="prettyprint">
      sensei.gateway.type=jdbc
    </pre>
    </li>
    <li><p>Kafka - each message is a data event, and offset is the version.</p>
    <p>Configuration:</p>
    <pre class="prettyprint">
      sensei.gateway.type=kafka
    </pre>
    </li>
  </ul>
</p>

<h2>Custom Gateways</h2>
<p>
  Data comes in from many different sources. While we are busy supporting more sources by writing Gateways, you can write your own custom gateways.
</p>
<p>
  To write your own custom gateway, follow the following steps:
</p>
<ol>
  <li>Implement SenseiGateway interface: 
     <pre class="prettyprint">

public class MyAwesomeGateway<V> extends SenseiGateway<V> {

  public MyAwesomeGateway(Configuration conf) {
    super(conf);
  }

  @Override
  public StreamDataProvider<JSONObject> buildDataProvider(
      DataSourceFilter<V> dataFilter, String oldSinceKey,
      ShardingStrategy shardingStrategy, Set<Integer> partitions)
      throws Exception {
      
      // build a StreamDataProvider instance
      
      ...
  }

  @Override
  public Comparator<String> getVersionComparator() {

    // tell us versioning semantics
    
    ...
  }

}

     </pre>
  </li>
  <li>
     Like any other extensions to Sensei, build it into a jar and copy it into the <code>conf/ext</code> directory, where <code>conf</code> contains configuration
     files.
  </li>
  <li>
     Edit <code>sensei.properties</code> to configure your Gateway:
     <pre class="prettyprint">
      sensei.gateway.type=custom
      sensei.gateway.custom.class = &lt;custom gateway class&gt;
      # paramters set to the gateway
      sensei.gateway.custom.param1 = &lt;value1&gt;
      sensei.gateway.custom.param2 = &lt;value2&gt;
     </pre>
  </li>
</ol>

<h2>Batch indexing</h2>
<p>Batch indexing over Hadoop is supported by Sensei. Go to: <a class="btn primary" href="/hadoop-bootstrap.html">Hadoop Bootstrap &raquo;</a>


<h2>Now that we know how to get data into Sensei...</h2>
<p>
  Let&apos; learn how to query Sensei:  <a class="btn primary" href="/clients.html">Clients &amp; APIs &raquo;</a>
 </p>