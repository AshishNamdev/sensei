---
layout: default
title: SenseiDB - FAQ
---
<div class="hero-unit">
  <h2>Frequently Asked Questions</h2>
</div>

<h2>Why did Sensei model Rest API after ElasticSearch Query DSL</h2>
<p>
  Aside from a few differences that are specific to Sensei, the Sensei Rest API is largely inspired by <a href="http://www.elasticsearch.org/guide/reference/query-dsl/">ElasticSearch&apos;s Query DSL</a>. ElasticSearch&apos;s Query DSL is very well designed in exposing <a href="http://lucene.apache.org/java/3_4_0/api/core/org/apache/lucene/search/Query.html">Lucene&apos;s query</a> capabilities and features in an elegant way. We didn&apos;t think it was necessary to create yet another API that is completely different.
</p>
<p>
  We have been engaging in dialogs with the ElasticSearch team in standardizing on a common API.
</p>

<hr/>
<h2>Why is Sensei use a pull-model for indexing instead of a push model like many other data systems, e.g. Solr, HBase, Cassandra, MongoDB etc.?</h2>
<p>
  One requirement for Sensei is to have extremely fast update rate (thousands per second) while not compromising on search performance. Having a push-model while maintaining data consistency between replications implies a cost per udpate event. Furthermore, this is an anti-scaling pattern as number of replications grows to accomodate high avalability, the cost for update increases. So as you add more machines to handle more traffic, this slows down update rate. 
</p>
<p>
  Therefore, it is a conscious design decision to avoid this cost. Though each replication is consuming from the data stream at presumablly different rates, each at Consistency is resolved a query time by consistent hashing on the <b><i>routing parameter</i></b> specified on the request.
</p>
<p>
  By having a data stream for consumption also provides the benefit of have a replaying mechanism which is very helpful in the cases of data re-balancing and re-indexing.
</p>

<hr/>
<h2>Are there plans to support dynamic schema like MongoDB or ElasticSearch?</h2>
<p>
 Yes. We are planning for early 2012 to have design in place.
</p>

<hr/>

<h2>Is BQL only for illustration purposes or is it a supported method to query Sensei?</h2>
<p>
	No, BQL is not only for illustration purposes, it is real.
</p>
<p>
  We are in the process of finalizing specs. for BQL. 
</p>
<p>
	Our intention is to support BQL as a first-class citizen in querying Sensei.
</p>
<hr/>


<h2>Is Sensei being developed outside of LinkedIn?</h2>
<p>
  Sensei is mostly under actively development within LinkedIn although we have been working with the community for quite a while, and there are some deployements outside of LinkedIn.
</p>
<p>
  While driving the project within LinkedIn benefits from traffic and data resources, we do believe letting the community drive and planning the roadmap is beneficial in the long run. So if you have passion and energy, visit <a href="/contribute.html">Contribute</a> page and contribute.
</p>
<hr/>

<h2>How mature is Sensei?</h2>
<p>
  Sensei is powering LinkedIn&apos;s homepage and the Signal application for the past year in production. Sensei components also have been powering many LinkedIn&apos;s Search properties, e.g. People, Jobs, Company etc. for years.
</p>
<p>
  We are interested in your help with other usages and deployments to make Sensei even more stable and performant! 
</p>
<hr/>
<h2>Seems indexing has stopped for no reason, what is wrong?</h2>
<p>
  It is possible one of the data events is erroneous, and by default Sensei stops indexing to maintain a consistent view. Look in the logs and see if you see an indexing exception.
</p>
<p>In applications where it is ok to skip bad records, you can set the <code>sensei.index.skipBadRecords</code> property in your <code>sensei.properties</code>, e.g.: 
</p>
<pre class="prettyprint">
	sensei.index.skipBadRecords = true  # default false
</pre>
<p>Be very careful with this setting because this may potentially cause inconsistency between node replicas</p>
<hr/>

<h2>After running a while, Sensei throws OOM (OutOfMemoryError), what is going on?</h2>
<p>
	By default, Sensei only allocates 1GB if heap space. As you accumulate documents and grow your corpus size, you need to configure the <code>HEAP_OPTS</code> in the <code>sensei.properties</code> file accordingly.
</p>
<pre class="prettyprint">
	HEAP_OPTS="-Xmx1g -Xms1g -XX:NewSize=256m"
</pre>
<hr/>

<h2>Got following compilation error, what is wrong?</h2>
<pre class="prettyprint" id="java">
	sensei-core/src/main/java/com/sensei/search/nodes/AbstractConsistentHashBroker.java:[217,47] type parameters of &lt;T&gt; T cannot be determined; no unique maximal instance exists for type variable T with upper bounds REQUEST,java.lang.Object
</pre>

<p>
	This is a known <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954">Java 1.6 bug</a> found in earlier builds. Upgrade your JDK to a more recent version.
</p>
<hr/>

<h2>Got compilation errors with Maven not able to find Kafka, what is wrong?</h2>
<p>
	Apache Kafka is not yet mavenized. You would have to deploy that into your local maven repository before compiling Sensei. To do this:
	<pre class="prettyprint">
	./bin/mvn-install.sh
	</pre>
</p>